
template <typename T, typename U, typename = std::make_index_sequence<std::tuple_size<U>::value>>
struct is_udf_compatible;

template <typename T, typename ... Ts, std::size_t... Is>
struct is_udf_compatible<T, std::tuple<Ts...>, std::index_sequence<Is...>>
  : public std::bool_constant<std::is_convertible_v<std::tuple_element_t<Is, Ts>, std::tuple_element_t<Is, typename T::traits::Inputs>> && ...> {};


template <typename T, typename... Args, std::size_t... Is>
auto ch_udf_impl(const source_location& sloc, const Args&... args, std::index_sequence<Is...>) {
  static_assert(is_udf_type_v<T>, "invalid type");
  static_assert(sizeof...(Args) == std::tuple_size_v<typename T::traits::Inputs>, "number of inputs mismatch");
  static_assert((std::is_convertible_v<Args, std::tuple_element_t<Is, typename T::traits::Inputs>> && ...), "invalid type for input");
  auto node = createUDFNode(get_udf<T>(), {to_lnode<std::tuple_element_t<Is, typename T::traits::Inputs>>(args, sloc)...}, sloc);
  return make_type<typename T::traits::Output>(node, sloc);
}

template <typename T, typename... Args, typename = void>
auto ch_udf(const Args&... args, CH_SLOC) {
  return ch_udf_impl<T, Args...>(sloc, args..., std::make_index_sequence<sizeof...(Args)>{});
}




const auto is_sync_rom = [](memimpl* /*node*/) {
  return false/*node->is_sync_read()
      && (1 == node->ports().size())
      && (type_mrport == node->ports()[0]->type())
      && !node->ports()[0]->has_enable()*/;
};



//--
if (is_sync_rom(node)) {
  auto port = reinterpret_cast<mrportimpl*>(node->ports()[0]);
  out << "always @ (";
  this->print_cdomain(out, node->cd());
  out << ") begin" << std::endl;
  {
    auto_indent indent(out);
    out << "case (";
    this->print_name(out, port->addr().impl());
    out << ")" << std::endl;
    {
      const auto& value = node->value();
      uint32_t num_items = node->num_items();
      uint32_t addr_width = ilog2(num_items);
      uint32_t data_width = node->data_width();
      for (uint32_t i = 0; i < num_items; ++i) {
        out << addr_width << "'d" << i << ": ";
        this->print_name(out, port);
        out << " = ";
        uint32_t offset = i * data_width;
        this->print_value(out, value, true, offset, data_width);
        out << ";" << std::endl;
      }
    }
    out << "endcase" << std::endl;
  }
  out << "end" << std::endl;
  return;
}
