for (int j = 0; j < 32; ++j) {
    std::cout << "CH_DEF_LITERALS_IMPL2(x";
    for (int i = 0; i < 32; ++i) {
        std::cout << ", " << i + 1 + j * 32;
    }
    std::cout << ") \\" << std::endl;
}

template <typename T, typename U, typename = std::make_index_sequence<std::tuple_size<U>::value>>
struct is_udf_compatible;

template <typename T, typename ... Ts, std::size_t... Is>
struct is_udf_compatible<T, std::tuple<Ts...>, std::index_sequence<Is...>>
  : public std::bool_constant<std::is_convertible_v<std::tuple_element_t<Is, Ts>, std::tuple_element_t<Is, typename T::traits::Inputs>> && ...> {};


template <typename T, typename... Args, std::size_t... Is>
auto ch_udf_impl(const source_location& sloc, const Args&... args, std::index_sequence<Is...>) {
  static_assert(is_udf_type_v<T>, "invalid type");
  static_assert(sizeof...(Args) == std::tuple_size_v<typename T::traits::Inputs>, "number of inputs mismatch");
  static_assert((std::is_convertible_v<Args, std::tuple_element_t<Is, typename T::traits::Inputs>> && ...), "invalid type for input");
  auto node = createUDFNode(get_udf<T>(), {to_lnode<std::tuple_element_t<Is, typename T::traits::Inputs>>(args, sloc)...}, sloc);
  return make_type<typename T::traits::Output>(node, sloc);
}

template <typename T, typename... Args, typename = void>
auto ch_udf(const Args&... args, CH_SLOC) {
  return ch_udf_impl<T, Args...>(sloc, args..., std::make_index_sequence<sizeof...(Args)>{});
}




const auto is_sync_rom = [](memimpl* /*node*/) {
  return false/*node->is_sync_read()
      && (1 == node->ports().size())
      && (type_mrport == node->ports()[0]->type())
      && !node->ports()[0]->has_enable()*/;
};



//--
if (is_sync_rom(node)) {
  auto port = reinterpret_cast<mrportimpl*>(node->ports()[0]);
  out << "always @ (";
  this->print_cdomain(out, node->cd());
  out << ") begin" << std::endl;
  {
    auto_indent indent(out);
    out << "case (";
    this->print_name(out, port->addr().impl());
    out << ")" << std::endl;
    {
      const auto& value = node->value();
      uint32_t num_items = node->num_items();
      uint32_t addr_width = ilog2(num_items);
      uint32_t data_width = node->data_width();
      for (uint32_t i = 0; i < num_items; ++i) {
        out << addr_width << "'d" << i << ": ";
        this->print_name(out, port);
        out << " = ";
        uint32_t offset = i * data_width;
        this->print_value(out, value, true, offset, data_width);
        out << ";" << std::endl;
      }
    }
    out << "endcase" << std::endl;
  }
  out << "end" << std::endl;
  return;
}

__if (ch_clock()) {
  ch_print("{0}: *** rd={0}, wr={1}, rd_a={2}, wr_a={3}, rd_val={4}, wr_val={5}, rd_dat={6}, wr_dat={7}",
           ch_now(), reading, writing, rd_a, wr_a, io.deq.valid, io.enq.valid, io.deq.data, io.enq.data);
};

template <typename T, unsigned N>
struct ch_queue {
  using value_type = T;
  static constexpr uint32_t max_size = N;
  static constexpr uint32_t addr_width = log2ceil(N);
  static constexpr uint32_t size_width = log2ceil(N+1);
  static_assert(N > 1, "invalid size");

  __io (
    (ch_enq_io<T>) enq,
    (ch_deq_io<T>) deq,
    __out(ch_uint<size_width>) size
  );

  void describe() {
    ch_reg<ch_uint<addr_width>> rd_ptr(0), wr_ptr(0);
    ch_reg<ch_uint<size_width>> counter(0);
    ch_reg<T> data_out;

    auto reading = io.deq.ready && io.deq.valid;
    auto writing = io.enq.valid && io.enq.ready;

    rd_ptr->next = ch_sel(reading, rd_ptr + 1, rd_ptr);
    wr_ptr->next = ch_sel(writing, wr_ptr + 1, wr_ptr);

    __if (writing && !reading) {
      counter->next = counter + 1;
    }__elif (reading && !writing) {
      counter->next = counter - 1;
    };

    auto rd_a = ch_slice<addr_width>(ch_sel(reading, rd_ptr + 1, rd_ptr));
    auto wr_a = ch_slice<addr_width>(wr_ptr);

    ch_mem<T, N> mem;
    mem.write(wr_a, io.enq.data, writing);

    auto first_write = writing && (0 == counter || (1 == counter && reading));
    data_out->next = ch_sel(first_write, io.enq.data, mem.read(rd_a));

    io.deq.data  = data_out;
    io.deq.valid = (counter != 0);
    io.enq.ready = (counter != N);
    io.size      = counter;
  }
};template <typename T>
void copy_bits(T* dst, uint32_t dst_offset, const T* src, uint32_t src_offset, uint32_t length) {
  static_assert(std::is_integral_v<T> && std::is_unsigned_v<T>, "invalid type");
  static unsigned constexpr WORD_SIZE = bitwidth_v<T>;
  static constexpr unsigned WORD_MASK = WORD_SIZE - 1;
  static constexpr T        WORD_MAX  = std::numeric_limits<T>::max();

  uint32_t w_src_begin_idx = src_offset / WORD_SIZE;
  uint32_t w_src_lsb = src_offset & WORD_MASK;
  uint32_t src_end         = src_offset + length - 1;
  uint32_t w_src_end_idx   = (src_end / WORD_SIZE) - w_src_begin_idx;
  auto w_src               = src + w_src_begin_idx;

  uint32_t w_dst_begin_idx = dst_offset / WORD_SIZE;
  uint32_t w_dst_lsb = dst_offset & WORD_MASK;
  uint32_t dst_end         = dst_offset + length - 1;
  uint32_t w_dst_end_idx   = (dst_end / WORD_SIZE) - w_dst_begin_idx;
  uint32_t w_dst_msb   = dst_end & WORD_MASK;
  auto w_dst               = dst + w_dst_begin_idx;

  if (length <= WORD_SIZE) {
    T src_block = (w_src[0] >> w_src_lsb);
    if (1 == w_src_end_idx) {
      src_block |= (w_src[1] << (WORD_SIZE - w_src_lsb));
    }
    if (0 == w_dst_end_idx) {
      T mask = (WORD_MAX >> (WORD_SIZE - length)) << w_dst_lsb;
      w_dst[0] = blend<T>(mask, w_dst[0], (src_block << w_dst_lsb));
    } else {
      T mask = WORD_MAX << w_dst_lsb;
      w_dst[0] = blend<T>(mask, w_dst[0], (src_block << w_dst_lsb));
      T src_block_new = src_block >> (WORD_SIZE - w_dst_lsb);
      mask = ~((WORD_MAX << 1) << w_dst_msb);
      w_dst[1] = blend<T>(mask, w_dst[1], src_block_new);
    }
  } else
  if (0 == w_dst_lsb
   && 0 == w_src_lsb) {
    // update aligned blocks
    if (WORD_MASK == w_dst_msb) {
      std::copy_n(w_src, w_dst_end_idx + 1, w_dst);
    } else {
      std::copy_n(w_src, w_dst_end_idx, w_dst);
      // update remining block
      T mask = (WORD_MAX << 1) << w_dst_msb;
      w_dst[w_dst_end_idx] = blend<T>(mask, w_src[w_dst_end_idx], w_dst[w_dst_end_idx]);
    }
  } else
  if (0 == w_src_lsb) {
    // update first block
    T src_block = w_src[0];
    T mask = WORD_MAX << w_dst_lsb;
    w_dst[0] = blend<T>(mask, w_dst[0], (src_block << w_dst_lsb));

    // update intermediate blocks
    for (uint32_t i = 1, n = w_src_end_idx; i < n; ++i) {
      T src_block_new = w_src[i];
      w_dst[i] = (src_block_new << w_dst_lsb) | ((src_block >> 1) >> (WORD_MASK - w_dst_lsb));
      src_block = src_block_new;
    }

    // update remining blocks
    T tmp = w_src[w_src_end_idx];
    T src_block_new = (tmp << w_dst_lsb) | ((src_block >> 1) >> (WORD_MASK - w_dst_lsb));
    if (w_src_end_idx < w_dst_end_idx) {
      w_dst[w_dst_end_idx-1] = src_block_new;
      src_block_new = (tmp >> 1) >> (WORD_MASK - w_dst_lsb);
    }
    mask = ~((WORD_MAX << 1) << w_dst_msb);
    w_dst[w_dst_end_idx] = blend<T>(mask, w_dst[w_dst_end_idx], src_block_new);
  } else {
    // update first block
    T src_block = w_src[0] >> w_src_lsb;
    src_block |= w_src[1] << (WORD_SIZE - w_src_lsb);
    T mask = WORD_MAX << w_dst_lsb;
    w_dst[0] = blend<T>(mask, w_dst[0], (src_block << w_dst_lsb));

    // update intermediate blocks
    for (uint32_t i = 1, n = std::min(w_src_end_idx, w_dst_end_idx); i < n; ++i) {
      T src_block_new = w_src[i] >> w_src_lsb;
      src_block_new |= w_src[i+1] << (WORD_SIZE - w_src_lsb);
      w_dst[i] = (src_block_new << w_dst_lsb) | ((src_block >> 1) >> (WORD_MASK - w_dst_lsb));
      src_block = src_block_new;
    }

    // update remining blocks
    T src_block_new;
    if (w_src_end_idx < w_dst_end_idx) {
      T tmp = w_src[w_src_end_idx] >> w_src_lsb;
      src_block_new = (tmp << w_dst_lsb) | ((src_block >> 1) >> (WORD_MASK - w_dst_lsb));
      w_dst[w_dst_end_idx-1] = src_block_new;
      src_block_new = (tmp >> 1) >> (WORD_MASK - w_dst_lsb);
    } else
    if (w_src_end_idx == w_dst_end_idx) {
      src_block_new = ((w_src[w_src_end_idx] >> w_src_lsb) << w_dst_lsb) | ((src_block >> 1) >> (WORD_MASK - w_dst_lsb));
    } else {
      src_block_new = ((w_src[w_src_end_idx-1] >> w_src_lsb) | (w_src[w_src_end_idx] << (WORD_SIZE - w_src_lsb))) << w_dst_lsb;
      src_block_new |= ((src_block >> 1) >> (WORD_MASK - w_dst_lsb));
    }
    mask = ~((WORD_MAX << 1) << w_dst_msb);
    w_dst[w_dst_end_idx] = blend<T>(mask, w_dst[w_dst_end_idx], src_block_new);
  }
}
